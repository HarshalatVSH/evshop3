import React, { memo } from 'react';
import PropTypes from 'prop-types';
import getExpMessage from './getExpMessage';

/* A component to simplify translations in our React components. It
will look on the window Exp object for a messages property and if it
finds a value for the key it will use that instead of the default.
We expect to use this to communicate with moment.js for date formatting,
as well as any other localization concerns we run into with currency and
number formatting. Always with defaults so that if the Exp object and
relevant properties within that don't exist the component will behave
normally, defaulting to US English.
 */

const computeMessage = (props) => {
  /**
   * Determine if any of the props.values are react elements
   * No:
   *  Carry on
   * Yes:
   *  Rip them out and replace them with a temporary generated token
   *  Generate the formatted message with the tokens in place
   *  Swap the tokens back out of the formatted message and replace them with their react elements
   * See also:
   *  https://github.com/yahoo/react-intl/blob/master/src/components/message.js
   */

  let counter = 0;
  const delimiter = '@__element__@';
  const elements = {};
  let hasElements = false;
  let { values } = props;

  if (typeof values !== 'object') {
    values = [values];
  }

  values = Object.keys(values).reduce((map, key) => {
    let newValue = values[key];

    // Replace any react elements with a temporary string token
    if (React.isValidElement(newValue)) {
      const token = `@__${counter += 1}__@`;

      hasElements = true;
      elements[token] = newValue;
      newValue = `${delimiter}${token}${delimiter}`;
    }

    return { ...map, [key]: newValue };
  }, {});

  let message = getExpMessage({ ...props, values });

  // Swap the temporary tokens back out for their element counterparts
  if (hasElements) {
    message = message
      .split(delimiter)
      .filter(part => !!part)
      .map(part => elements[part] || part);
  } else {
    // Wrap the final message so we dont end up spreading the message into a thousand individual
    // char elements when we render
    message = [message];
  }

  return message;
};

const ExpLabel = (props) => {
  // Blacklist any props that we're either adding below or are using above that shouldn't end up
  // on the underlying component
  const {
    className,
    defaultMessage,
    messageKey,
    namespace,
    tagName,
    values,
    ...renderProps
  } = props;

  const message = computeMessage(props);

  // Use createElement instead of jsx to get around react complaining about not having keys set on
  // the child nodes in this.state.message
  return React.createElement(tagName, {
    ...renderProps,
    className: `exp-label ${className || ''}`,
    'data-namespace': namespace,
    'data-message-key': messageKey,
  }, ...message);
};

ExpLabel.defaultProps = {
  className: null,
  namespace: '',
  tagName: 'span',
  values: [],
};

ExpLabel.propTypes = {
  className: PropTypes.string,
  defaultMessage: PropTypes.string.isRequired,
  messageKey: PropTypes.string.isRequired,
  namespace: PropTypes.string,
  tagName: PropTypes.string,
  values: PropTypes.any,
};

export default memo(ExpLabel);
